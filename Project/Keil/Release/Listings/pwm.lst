C51 COMPILER V9.60.7.0   PWM                                                               07/01/2024 14:06:54 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE PWM
OBJECT MODULE PLACED IN .\Release\Objects\pwm.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\pwm.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X000C) INCDIR
                    -(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\pwm.lst) OBJECT(.\Release\O
                    -bjects\pwm.obj)

line level    source

   1          #include "pwm.h"
   2          #include "time0.h"
   3          
   4          volatile u16 c_duty = 0;         // 当前设置的占空比
   5          volatile u16 adjust_duty = 6000; // 最终要调节成的占空比
   6          bit jump_flag = 0;
   7          bit max_flag = 0; // 最大占空比的标志位
   8          
   9          void pwm_init(void)
  10          {
  11   1          STMR_CNTCLR |= STMR_0_CNT_CLR(0x1);
  12   1      #define STMR0_PEROID_VAL (SYSCLK / 8000 - 1)
  13   1          STMR0_PSC = STMR_PRESCALE_VAL(0x07);
  14   1          STMR0_PRH = STMR_PRD_VAL_H((STMR0_PEROID_VAL >> 8) & 0xFF);
  15   1          STMR0_PRL = STMR_PRD_VAL_L((STMR0_PEROID_VAL >> 0) & 0xFF);
  16   1          STMR0_CMPAH = STMR_CMPA_VAL_H(((0) >> 8) & 0xFF); // 比较值
  17   1          STMR0_CMPAL = STMR_CMPA_VAL_L(((0) >> 0) & 0xFF); // 比较值
  18   1          STMR_PWMVALA |= STMR_0_PWMVALA(0x1);
  19   1      
  20   1          STMR_CNTMD |= STMR_0_CNT_MODE(0x1); // 连续计数模式
  21   1          STMR_LOADEN |= STMR_0_LOAD_EN(0x1); // 自动装载使能
  22   1          STMR_CNTCLR |= STMR_0_CNT_CLR(0x1); //
  23   1          STMR_CNTEN |= STMR_0_CNT_EN(0x1);   // 使能
  24   1          STMR_PWMEN |= STMR_0_PWM_EN(0x1);   // PWM输出使能
  25   1          P1_MD1 &= ~GPIO_P16_MODE_SEL(0x03);
  26   1          P1_MD1 |= GPIO_P16_MODE_SEL(0x01);
  27   1          P1_MD1 &= ~GPIO_P14_MODE_SEL(0x03);
  28   1          P1_MD1 |= GPIO_P14_MODE_SEL(0x01);
  29   1          FOUT_S14 = GPIO_FOUT_AF_FUNC;      // AF功能输出
  30   1          FOUT_S16 = GPIO_FOUT_STMR0_PWMOUT; // stmr0_pwmout
  31   1      }
  32          
  33          // 14脚的PWM调节
  34          void set_pwm_duty(void)
  35          {
  36   1          STMR0_CMPAH = STMR_CMPA_VAL_H(((c_duty) >> 8) & 0xFF); // 比较值
  37   1          STMR0_CMPAL = STMR_CMPA_VAL_L(((c_duty) >> 0) & 0xFF); // 比较值
  38   1          STMR_LOADEN |= STMR_0_LOAD_EN(0x1);                    // 自动装载使能
  39   1      }
  40          
  41          // 根据9脚的电压来调节PWM
  42          void _My_Adjust_Pwm(float Val)
  43          {
  44   1          float P9_Vol = Val * 0.0012;
  45   1      
  46   1      #if USE_MY_DEBUG
                  printf("9脚检测到的电压： %f V\n", P9_Vol);
              #endif
  49   1      
  50   1          //  printf("P9_Vol %d\n",P9_Vol);
  51   1          ////////////控制14脚///////////////////   100 -> 80   7.5ms          80 -> 50  5ms     100 -> 50  3ms
  52   1      
  53   1          // 当9脚电压高于1.9V时，14脚输出100%的PWM信号
C51 COMPILER V9.60.7.0   PWM                                                               07/01/2024 14:06:54 PAGE 2   

  54   1          if (P9_Vol > 1.90) // 输出100%
  55   1          {
  56   2              //      printf(" P9_Vol : %f.... 100\n",P9_Vol);
  57   2              adjust_duty = 6000;
  58   2              max_flag = 1;
  59   2          }
  60   1          else if (P9_Vol > 1.6 && P9_Vol < 1.9) // 缓降80%
  61   1          {
  62   2              // 9脚电压在1.6~1.9V时，14脚输出的占空比从100%缓降到80%
  63   2      
  64   2              //      printf(" P9_Vol : %f...... 80\n",P9_Vol);
  65   2              if (max_flag == 1)
  66   2              {
  67   3                  if (P9_Vol < 1.85)
  68   3                  {
  69   4                      adjust_duty = 4800;
  70   4                      max_flag = 0;
  71   4                  }
  72   3              }
  73   2              else
  74   2              {
  75   3                  adjust_duty = 4800;
  76   3              }
  77   2      
  78   2              if (c_duty >= adjust_duty)
  79   2                  jump_flag = 1;
  80   2          }
  81   1          else if (P9_Vol < 1.6) // 缓降50%  并且维持50%
  82   1          {
  83   2              // 9脚电压小于1.6V，14输出的占空比从80%缓降到50%，并保持50%
  84   2      
  85   2              // printf(" P9_Vol : %f...... 50\n",P9_Vol);
  86   2              // adjust_duty = 3000;
  87   2              adjust_duty = PWM_DUTY_50_PERCENT;
  88   2              max_flag = 0;
  89   2              if (c_duty >= adjust_duty)
  90   2                  jump_flag = 1;
  91   2          }
  92   1          ///////////////控制16脚//////////////////
  93   1          // 当9脚电压高于2.7V时，16脚输出1KHz 高电平,用于控制Q2的导通。
  94   1          if (P9_Vol > 2.7) // 16脚输出1KHZ的高电平
  95   1          {
  96   2              P14 = 1;
  97   2          }
  98   1          else // 16脚输出1KHZ的低电平
  99   1          {
 100   2              P14 = 0;
 101   2          }
 102   1      }
 103          
 104          // 根据9脚的电压来设定16脚的电平
 105          void according_pin9_to_adjust_pin16(void)
 106          {
 107   1          u8 i = 0;                         // 循环计数值
 108   1          u8 cnt = 0;                       // 计数值
 109   1          volatile u32 adc_aver_val = 0;    // 存放adc滤波后的值
 110   1          adc_sel_pin(ADC_SEL_PIN_GET_VOL); // 切换到9脚对应的adc配置
 111   1      
 112   1          // 采集电压
 113   1          for (i = 0; i < 10; i++)
 114   1          {
 115   2              adc_aver_val = get_voltage_from_pin();
C51 COMPILER V9.60.7.0   PWM                                                               07/01/2024 14:06:54 PAGE 3   

 116   2              if (adc_aver_val >= 2700)
 117   2              {
 118   3                  // 如果从9脚上采集的电压大于2.7V
 119   3                  cnt++;
 120   3              }
 121   2          }
 122   1      
 123   1          // 当9脚电压高于2.7V时，16脚输出1KHz 高电平,用于控制Q2的导通（用于关机）。
 124   1          if (cnt == 10)
 125   1          {
 126   2              // 如果多次检测都满足条件，才认为9脚的电压确实大于2.7V
 127   2              P14 = 1;
 128   2          }
 129   1          else
 130   1          {
 131   2              P14 = 0;
 132   2          }
 133   1      }
 134          
 135          // 缓慢调节占空比（缓慢提升和缓慢下降）
 136          void Adaptive_Duty(void)
 137          {
 138   1          if (c_duty > adjust_duty)
 139   1          {
 140   2              c_duty--;
 141   2          }
 142   1          if (c_duty < adjust_duty)
 143   1          {
 144   2              c_duty++;
 145   2          }
 146   1          set_pwm_duty();
 147   1      
 148   1          if (c_duty >= 5800)
 149   1          {
 150   2      
 151   2              delay_ms(15); // 时间还需要测试调整一下
 152   2          }
 153   1          else
 154   1          {
 155   2              delay_ms(5);
 156   2          }
 157   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    611    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      4      14
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
